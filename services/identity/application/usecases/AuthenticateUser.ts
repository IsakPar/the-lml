import { Result } from '@thankful/shared';
import { UserRepository, RepositoryError } from '../ports/UserRepository.js';
import { SessionRepository, CreateSessionParams, DeviceType } from '../ports/SessionRepository.js';
import { PasswordService, PasswordError } from '../ports/PasswordService.js';
import { Email } from '../../domain/valueobjects/Email.js';
import { User } from '../../domain/entities/User.js';

/**
 * Authenticate User Use Case
 * Handles user login with session management
 */
export class AuthenticateUser {
  constructor(
    private userRepository: UserRepository,
    private sessionRepository: SessionRepository,
    private passwordService: PasswordService
  ) {}

  /**
   * Execute authentication
   */
  async execute(command: AuthenticateUserCommand): Promise<Result<AuthenticationResult, AuthenticationError>> {
    // Validate email format
    const emailResult = Email.create(command.email);
    if (emailResult.isFailure) {
      return Result.failure(AuthenticationError.invalidCredentials('Invalid email format'));
    }

    // Find user by email
    const userResult = await this.userRepository.findByEmail(emailResult.value);
    if (userResult.isFailure) {
      return Result.failure(AuthenticationError.repositoryError(userResult.error.message));
    }

    const user = userResult.value;
    if (!user) {
      return Result.failure(AuthenticationError.invalidCredentials('Invalid email or password'));
    }

    // Check if user account is active
    if (!user.isActive()) {
      return Result.failure(AuthenticationError.accountInactive('Account has been deactivated'));
    }

    // Verify password
    if (!user.getPasswordHash()) {
      return Result.failure(AuthenticationError.invalidCredentials('Account requires password reset'));
    }

    const passwordResult = await this.passwordService.verify(command.password, user.getPasswordHash()!);
    if (passwordResult.isFailure || !passwordResult.value) {
      return Result.failure(AuthenticationError.invalidCredentials('Invalid email or password'));
    }

    // Check if email is verified for critical operations
    if (command.requireEmailVerification && !user.isEmailVerified) {
      return Result.failure(AuthenticationError.emailNotVerified('Email verification required'));
    }

    // Create session
    const sessionParams: CreateSessionParams = {
      userId: user.getId(),
      deviceId: command.deviceId,
      deviceType: command.deviceType,
      deviceName: command.deviceName,
      ipAddress: command.ipAddress,
      userAgent: command.userAgent,
      expiresAt: this.calculateSessionExpiry(command.rememberMe || false),
    };

    const sessionResult = await this.sessionRepository.create({
      id: '', // Will be generated by repository
      tokenHash: this.generateSessionToken(),
      isActive: true,
      createdAt: new Date(),
      lastAccessedAt: new Date(),
      ...sessionParams,
    });

    if (sessionResult.isFailure) {
      return Result.failure(AuthenticationError.sessionCreationFailed(sessionResult.error.message));
    }

    // Update user's last login time
    await this.userRepository.updateLastLogin(user.getId());

    // Return authentication result
    const result: AuthenticationResult = {
      user: {
        id: user.getId(),
        email: user.getEmail().value,
        firstName: user.getProfile().value.firstName,
        lastName: user.getProfile().value.lastName,
        role: user.getRole(),
        isEmailVerified: user.isEmailVerified,
        isPhoneVerified: user.isPhoneVerified,
        preferences: user.getProfile().value.preferences,
      },
      session: sessionResult.value,
      token: this.generateJWT(user, sessionResult.value),
      expiresAt: sessionResult.value.expiresAt,
    };

    return Result.success(result);
  }

  /**
   * Calculate session expiry based on remember me option
   */
  private calculateSessionExpiry(rememberMe: boolean): Date {
    const now = new Date();
    const hours = rememberMe ? 24 * 30 : 24; // 30 days vs 1 day
    return new Date(now.getTime() + hours * 60 * 60 * 1000);
  }

  /**
   * Generate session token (simplified - would use crypto in real implementation)
   */
  private generateSessionToken(): string {
    return Buffer.from(Date.now().toString() + Math.random().toString()).toString('base64');
  }

  /**
   * Generate JWT token (simplified - would use proper JWT library)
   */
  private generateJWT(user: User, session: any): string {
    const payload = {
      sub: user.getId(),
      email: user.getEmail().value,
      role: user.getRole(),
      sessionId: session.id,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(session.expiresAt.getTime() / 1000),
    };

    // In real implementation, would use jsonwebtoken library
    return Buffer.from(JSON.stringify(payload)).toString('base64');
  }
}

/**
 * Authentication command
 */
export interface AuthenticateUserCommand {
  email: string;
  password: string;
  deviceId?: string;
  deviceType?: DeviceType;
  deviceName?: string;
  ipAddress?: string;
  userAgent?: string;
  rememberMe?: boolean;
  requireEmailVerification?: boolean;
}

/**
 * Authentication result
 */
export interface AuthenticationResult {
  user: {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    role: string;
    isEmailVerified: boolean;
    isPhoneVerified: boolean;
    preferences: Record<string, any>;
  };
  session: {
    id: string;
    expiresAt: Date;
    deviceType?: DeviceType;
    deviceName?: string;
  };
  token: string;
  expiresAt: Date;
}

/**
 * Authentication error types
 */
export interface AuthenticationError {
  type: 'INVALID_CREDENTIALS' | 'ACCOUNT_INACTIVE' | 'EMAIL_NOT_VERIFIED' | 'SESSION_CREATION_FAILED' | 'REPOSITORY_ERROR';
  message: string;
  details?: Record<string, any>;
}

/**
 * Helper to create authentication errors
 */
export const AuthenticationError = {
  invalidCredentials: (message: string): AuthenticationError => ({
    type: 'INVALID_CREDENTIALS',
    message,
  }),

  accountInactive: (message: string): AuthenticationError => ({
    type: 'ACCOUNT_INACTIVE',
    message,
  }),

  emailNotVerified: (message: string): AuthenticationError => ({
    type: 'EMAIL_NOT_VERIFIED',
    message,
  }),

  sessionCreationFailed: (message: string): AuthenticationError => ({
    type: 'SESSION_CREATION_FAILED',
    message,
  }),

  repositoryError: (message: string): AuthenticationError => ({
    type: 'REPOSITORY_ERROR',
    message,
  }),
};
